#pragma once

#include <cstdint>
#include <map>
#include <memory>
#include <set>
#include <vector>

#ifdef BOOST_PYTHON_EXTENSIONS
#include <boost/python.hpp>
namespace p = boost::python;
#endif

#include "../Variable.hpp"
#include "it/EntropyCalculator.hpp"

namespace mist {

namespace algorithm {

/** Interface for processing tuples in the TupleSpace
 *
 * A class can specialize the TupleSpaceTraverser to gain access to the stream
 * of tuples generated by TupleSpace::traverse family of functions.
 */
class TupleSpaceTraverser {
public:
  using tuple_t = Variable::indexes;
  using count_t = std::uint64_t;
  virtual void process_tuple(count_t tuple_no, tuple_t const& tuple) = 0;
  virtual void process_tuple_entropy(
      count_t tuple_no, tuple_t const& tuple, it::Entropy const& e) = 0;
};

/** Tuple Space defines the set of tuples over which to run a computation
 * search.
 */
class TupleSpace
{
public:
  using tuple_t = Variable::indexes;
  using index_t = Variable::index_t;
  using count_t = std::uint64_t;
  TupleSpace();
  TupleSpace(int N, int d);
  ~TupleSpace();
  /** Define a named logical group of variables
   * @param name group name
   * @param vars set of variables in the group, duplicates will be ignored
   * @return index of created variable group
   * @throws TupleSpaceException variable already listed in existing variable
   * group
   */
  int addVariableGroup(std::string const& name, tuple_t const& vars);
  /** Add a variable group tuple
   *
   * The cross product of groups in the group tuple generates a set of
   * variable tuples that will be added to the TupleSpace by
   * TupleSpaceTupleProducer.
   *
   * @param groups Array of group names
   * @throws TupleSpaceException group does not exists
   */
  void addVariableGroupTuple(std::vector<std::string> const& groups);
  /** Add a variable group tuple
   *
   * The cross product of groups in the group tuple generates a set of
   * variable tuples that will be added to the TupleSpace by
   * TupleSpaceTupleProducer.
   *
   * @param groups Array of group indexed by order created
   * @throws TupleSpaceException group index out of range
   */
  void addVariableGroupTuple(tuple_t const& groups);
  /** Get variable names
   */
  std::vector<std::string> names() const;
  /** Set variable names
   */
  void set_names(std::vector<std::string> const& names);
  int tupleSize() const;

#if BOOST_PYTHON_EXTENSIONS
  int pyAddVariableGroup(std::string const& name, p::list const& list);
  void pyAddVariableGroupTuple(p::list const& list);
#endif

  /** Calculate the size of the tuple space, i.e. count the generated number of
   * tuples.
   */
  count_t count_tuples() const;
  count_t count_tuples_group_tuple(tuple_t const&) const;
  tuple_t find_tuple(count_t target) const;
  tuple_t const& getVariableGroup(int index) const;
  tuple_t const& getVariableGroup(std::string const& name) const;
  std::vector<std::size_t> const& getVariableGroupSizes() const;
  tuple_t const& getVariableGroupAppearances(int index) const;
  std::vector<tuple_t> const& getVariableGroups() const;
  std::vector<tuple_t> const& getVariableGroupTuples() const;

  /** Walk through all tuples in the tuple space
   * @param traverser Process each tuple with methods defined in specialization
   */
  void traverse(TupleSpaceTraverser& traverser) const;
  /** Walk through as subset of tuples in the tuple space
   *
   * TupleSpace generates an ordered list of tuples, that can begin at any
   * position in the list.
   *
   * @param start Begin the walk at tuple in position start
   * @param stop End the walk at tuple in position stop
   * @param traverser Process each tuple with methods defined in specialization
   */
  void traverse(count_t start, count_t stop, TupleSpaceTraverser& traverser) const;
  /** Walk through all tuples in the tuple space, computing entropy values as
   * you go.
   *
   * Some it::Measure classes compute the entropy values of sub-tuples. It is
   * most efficient to compute these as you walk through the tuple space so
   * intermediary values can be reused many times.
   *
   * @param ecalc it::EntropyCalculator object to perform entropy computations
   * @param traverser Process each tuple with methods defined in specialization
   */
  void traverse_entropy(it::EntropyCalculator &ecalc, TupleSpaceTraverser& traverser) const;
  /** Walk through a subset of tuples in the tuple space, computing entropy values as
   * you go.
   */
  void traverse_entropy(count_t start, count_t stop, it::EntropyCalculator &ecalc, TupleSpaceTraverser& traverser) const;

private:
  // variable names, e.g. from data header
  std::vector<std::string> variableNames;
  // groups of variables that construct a tuple
  std::vector<tuple_t> variableGroups;
  std::vector<std::size_t> variableGroupSizes;
  // names for the variable groups and their identifying index
  std::map<std::string, int> variableGroupNames;
  // list of groups that define variable tuples
  std::vector<tuple_t> variableGroupTuples;
  // keep track of seen variables to detect duplicates
  std::set<int> seen_vars;
  int tuple_size = 0;
};

class TupleSpaceException : public std::exception
{
private:
  std::string msg;

public:
  TupleSpaceException(std::string const& method, std::string const& msg)
    : msg("TupleSpace" + method + " : " + msg)
  {}
  virtual const char* what() const throw() { return msg.c_str(); };
};

} // algorithm
} // mist
