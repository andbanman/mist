#include <iostream> //DEBUG

#include "algorithm/Worker.hpp"
#include "it/Entropy.hpp"
#include "it/SymmetricDelta.hpp"

using namespace mist;
using namespace mist::algorithm;

void
Worker::processTuple(tuple_t const& tuple)
{
  auto result = this->measure->compute(*this->calc, tuple);
  for (auto& out : out_streams) {
    if (this->output_all) {
      out->push(tuple, result);
    } else {
      out->push(tuple,
                it::Measure::result_type(result.end() - 1, result.end()));
    }
  }
}

void
Worker::processTuple(tuple_t const& tuple, it::Entropy const& e)
{
  auto result = this->measure->compute(*this->calc, tuple, e);
  for (auto& out : out_streams) {
    if (this->output_all) {
      out->push(tuple, result);
    } else {
      out->push(tuple,
                it::Measure::result_type(result.end() - 1, result.end()));
    }
  }
}

void
Worker::search_d1(long start, long stop, bool full)
{
  auto const& groups = ts.getVariableGroups();
  auto const& group_tuples = ts.getVariableGroupTuples();
  auto const& N = ts.getVariableGroupSizes();
  int ngroups = groups.size();
  int ngtuples = group_tuples.size();

  // tuple generation state
  bool init = true;
  bool work = true;
  int count = start;
  tuple_t starts(ngroups);
  starts.assign(ngroups,0);
  it::Entropy entropy((int)it::d1::size);
  tuple_t tuple(1);

  // fast-forward to starting group and tuple
  auto ffw = ts.find_tuple(start);

  // computation step
  for (int gg = ffw[0]; gg < ngtuples; gg++) {
    int gi = group_tuples[gg][0];
    for (int ii = (init) ? ffw[1] : 0; ii < N[gi] && work; ii++) {
      tuple[0] = groups[gi][ii];
      if (full) {
        entropy[(int)it::d1::e0] = this->calc->entropy({ tuple[0] });
        processTuple(tuple, entropy);
      } else {
        processTuple(tuple);
      }
      count++;
      init = false;
      work = count < stop;
    }
  }
}

void
Worker::search_d2(long start, long stop, bool full)
{
  auto const& groups = ts.getVariableGroups();
  auto const& group_tuples = ts.getVariableGroupTuples();
  auto const& N = ts.getVariableGroupSizes();
  int ngroups = groups.size();
  int ngtuples = group_tuples.size();

  // tuple generation state
  bool init = true;
  bool work = true;
  int count = start;
  tuple_t starts(ngroups);
  starts.assign(ngroups,0);
  it::Entropy entropy((int)it::d2::size);
  tuple_t tuple(2);

  // fast-forward to starting group and tuple
  auto ffw = ts.find_tuple(start);

  // computation step
  for (int gg = ffw[0]; gg < ngtuples; gg++) {
    int gi = group_tuples[gg][0];
    int gj = group_tuples[gg][1];

    // loop through all tuples generated by this group tuple
    for (int ii = (init) ? ffw[1] : starts[gi]; ii < N[gi] && work; ii++) {
      starts[gi] = ii + 1;
      tuple[0] = groups[gi][ii];
      if (full) {
        entropy[(int)it::d2::e0] = this->calc->entropy({ tuple[0] });
      }
      for (int jj = (init) ? ffw[2] : starts[gj]; jj < N[gj] && work; jj++) {
        starts[gj] = jj + 1;
        tuple[1] = groups[gj][jj];
        if (full) {
          entropy[(int)it::d2::e1] = this->calc->entropy({ tuple[1] });
          entropy[(int)it::d2::e01] =
            this->calc->entropy({ tuple[0], tuple[1] });
          processTuple(tuple, entropy);
        } else {
          processTuple(tuple);
        }
        count++;
        init = false;
        work = count < stop;
      }
      starts[gj] = 0;
    }
    starts[gi] = 0;
  }
}

void
Worker::search_d3(long start, long stop, bool full)
{
  auto const& groups = ts.getVariableGroups();
  auto const& group_tuples = ts.getVariableGroupTuples();
  auto const& N = ts.getVariableGroupSizes();
  int ngroups = groups.size();
  int ngtuples = group_tuples.size();

  // tuple generation state
  bool init = true;
  bool work = true;
  int count = start;
  tuple_t starts(ngroups);
  starts.assign(ngroups,0);
  it::Entropy entropy((int)it::d3::size);
  tuple_t tuple(3);

  // fast-forward to starting group and tuple
  auto ffw = ts.find_tuple(start);

  // computation step
  for (int gg = ffw[0]; gg < ngtuples; gg++) {
    int gi = group_tuples[gg][0];
    int gj = group_tuples[gg][1];
    int gk = group_tuples[gg][2];

    // loop through all tuples generated by this group_tuple
    for (int ii = (init) ? ffw[1] : starts[gi]; ii < N[gi] && work; ii++) {
      starts[gi] = ii + 1;
      tuple[0] = groups[gi][ii];
      if (full) {
        entropy[(int)it::d3::e0] = this->calc->entropy({ tuple[0] });
      }
      for (int jj = (init) ? ffw[2] : starts[gj]; jj < N[gj] && work; jj++) {
        starts[gj] = jj + 1;
        tuple[1] = groups[gj][jj];
        if (full) {
          entropy[(int)it::d3::e1] = this->calc->entropy({ tuple[1] });
          entropy[(int)it::d3::e01] =
            this->calc->entropy({ tuple[0], tuple[1] });
        }
        for (int kk = (init) ? ffw[3] : starts[gk]; kk < N[gk] && work; kk++) {
          starts[gk] = kk + 1;
          tuple[2] = groups[gk][kk];
          if (full) {
            entropy[(int)it::d3::e2] = this->calc->entropy({ tuple[2] });
            entropy[(int)it::d3::e02] =
              this->calc->entropy({ tuple[0], tuple[2] });
            entropy[(int)it::d3::e12] =
              this->calc->entropy({ tuple[1], tuple[2] });
            entropy[(int)it::d3::e012] = this->calc->entropy(tuple);
            processTuple(tuple, entropy);
          } else {
            processTuple(tuple);
          }
          count++;
          init = false;
          work = count < stop;
        }
        starts[gk] = 0;
      }
      starts[gj] = 0;
    }
    starts[gi] = 0;
  }
}

void
Worker::start()
{
  TupleSpace::tuple_index_t total = (limit) ? limit : ts.count_tuples();
  TupleSpace::tuple_index_t step = (total + this->ranks - 1) / this->ranks; // round up
  TupleSpace::tuple_index_t start = step * (this->rank);
  TupleSpace::tuple_index_t stop = start + step;
  TupleSpace::tuple_index_t d = ts.getVariableGroupTuples().front().size();
  bool full = measure->full_entropy();

  // hard stop the last rank
  if (rank == ranks - 1) {
    stop = total;
  }

  // rounding can cause the start to go past the end, stop if theres' no work
  // for this rank to do
  if (start >= total) {
    return;
  }

  switch (d) {
    case 1:
      search_d1(start, stop, full);
      break;
    case 2:
      search_d2(start, stop, full);
      break;
    case 3:
      search_d3(start, stop, full);
      break;
    default:
      throw WorkerException("start",
                            "Unsupported tuple size " + std::to_string(d) +
                              " for full-entropy measure, valid range [1,3]");
  }
}

Worker::~Worker() {}
Worker::Worker() {}

Worker::Worker(int rank,
               int ranks,
               long limit,
               TupleSpace const& ts,
               entropy_calc_ptr calc,
               std::vector<output_stream_ptr> out_streams,
               measure_ptr measure)
  : ts(ts)
  , rank(rank)
  , ranks(ranks)
  , limit(limit)
  , calc(calc)
  , out_streams(out_streams)
  , measure(measure)
{
  // cannot set these in member initialization list?
  if (ts.getVariableGroups().empty()) {
    throw WorkerException("Worker", "TuplesSpace variable groups empty.");
  }
  if (ts.getVariableGroupTuples().empty()) {
    throw WorkerException("Worker", "TuplesSpace variable group tuples empty.");
  }
  for (auto& out : out_streams) {
    if (!out) {
      throw WorkerException("Worker", "Invalid output stream");
    }
  }
}
